= Прототип автоматического распараллеливания
v1.0, 22.12.2017: First prototype
:hardbreaks:
:imagesdir: images

== 1 Начало работы с конфигуратором

	Перед созданием рецепта пользователю предлагается пройти обучение, в котором он познакомится с основными возможностями конфигуратора.

=== 1.1 Создание списка необходимых продуктов

 После окончания обучения или, если пользователь не захотел его проходить, он увидит меню, в котором ему предлагается выбрать все продукты для приготовления. Он в условно-табличном виде выбирает продукты, их количество. А так же может оставить заметку в свободной форме с рекомендациями по выбору, например, сорта яблок.

 Так как пользователь может ошибиться с количеством того или иного продукта, я предлагаю создать возможность вызова этого меню по кнопке в процессе создания рецепта. Для контроля было бы неплохо создать еще один столбец меню, в котором можно указывать остаток продукта.

 Например, к шагу №10 осталось только 2 яблока, а на этом шаге нужно 3 яблока. Тогда пользователь посмотрит, что ему не хватает 1 яблока и добавит его.
	
	Список продуктов необходим:
	
	. Чтобы исключить инвариантность названия одного и того же продукта в ходе создания рецепта (морковь и морковка обозначают одно и тоже, но автоматизировать распараллеливание в этом случае будет сложнее).
	
	. Чтобы исключить ситуацию, когда пользователь в одном шаге нарезал половину моркови, а на следующем шаге предлагает добавить морковь к луку(в этом случае непонятно, возможно он имеет ввиду нарезанную морковь, а возможно и целую). Решением будет создание условий, при котором пользователь выберет морковь либо из списка оставшихся продуктов, либо выберет шаг, на котором мы получили нарезанную морковь.
	
=== 1.2 Добавление шагов

	Пользователю предоставляется возможность создать шаги, путем написания текста и добавления фотографий. В целях автоматизации распараллеливания, предлагаю: дать пользователю возможность создать шаги, используя шаблоны приложения (изложены в Приложении A). Но есть проблема – я набросал по двум рецептам шаблоны и их получится около 10 штук. Смысл в том, что вначале пользователь выбирает действие (их около 10), а потом шаблон автоматически перестраивается под выбранное действие. И вот нужно как-то это 10 действий отображать, или делать так, чтобы действия предлагались как у поисковых систем (пользователь вводит по 1 букве и ему показывается первые 3-4 совпадения).
    
    Т.е. это будет выглядеть примерно так (промежуточный результат заполнения):
    
    Смешать рис, фасоль.
    
    Как вариант, выбор первого слова (действия) можно делать из круговой диаграммы, там можно сделать подпись действия и разместить иллюстрацию действия. Еще не использованные продукты я предлагаю выбирать из меню, описанного в пункте 1.1 или аналогичного по дизайну. А выбор уже как-то обработанных продуктов делать из такого меню:

image::PrototypeA1.png[]

= 2 Пример разбиения на шаги двух рецептов
== 2.1 Мясные рулетики

 Шаги:
 
 . Нарезать говядину кусочками
 . Отбить (1)
 . Поперчить (2)
 . Нарезать помидор брусочками
 . Нарезать сыр брусочками
 . Положить на (1) один (5)
 . Положить на (6) один (4)
 . Свернуть (7) в рулетик
 . Нагреть масло оливковое в сковороде
 . Обжарить (8) с двух сторон до румяности
 . Нарезать морковь брусочками
 . Нарезать лук полукольцами
 . Смешать (9), морковь, лук
 . Жарить (13) до золотистого цвета
 . Нарезать помидоры кубиками
 . Нарезать сельдерей кубиками
 . Нарезать чеснок кубиками
 . Смешать (14), (15), (16), (17), зеленый горошек
 . Нарезать картофель кусочками (крупными)
 . Выложить (19) в форму для запекания
 . Добавить (18) в (20)
 . Выложить (10) в (21)
 . Запекать (22) в течении 40 минут при 200 С

== 2.2 Плов

 Шаги:
 
 . Нарезать лук соломкой
 . Нарезать <мясо> кусочками (небольшими)
 . Нарезать морковь брусочками
 . Смешать (1), растительное масло
 . Обжарить (4) до золотистого цвета
 . Смешать (5), (2), (3)
 . Тушить (6) 5-7 минут
 . Смешать (7), зиру, барбарис, куркуму, соль, перец
 . Смешать (8), воду
 . Тушить (9) на среднем огне
 . Промыть рис (5-6 раз) в холодной воде
 . Смешать (10), (11) (с мясом не перемешивать)
 . Смешать (12), воду <модификатор>(пример - Аккуратно влить горячую или теплую воду так, чтобы она покрывала рис на 2 см), соль
 . Варить (13) пока рис не впитает воду
 . Положить чеснок в 14<модификатор>(пример - середина)(вдавить его в рис. Деревянной палочкой сделать отверстия (рис и мясо не перемешивать) для выхода пара.)
 . Варить 20 минут

= 3 Описание алгоритма составления графа для распараллеливания

image::PrototypeA2.png[]

== 3.1 Граф для мясных рулетиков

image::PrototypeA3.png[]

== 3.2 Граф для плова

image::PrototypeA4.png[]

== 3.3 Описание распараллеливания для n-ого числа людей

 Основной способ преобразования изложен в приложении B. Разница лишь в том, что мы для выполнения всех работ используем всегда 1 человека. Потому что все работы сформированы по принципу максимальной простоты.
 
 Но в большинстве процентов случаев не получится оптимизировать так, что бы общее время выполнения оставалось неизменным. В пунктах 3.1 и 3.2 изображены графы, которые максимально сокращают время готовки, но, например, для 1 человека точно не выйдет отставить время готовки таким же коротким, потому что некуда “двигать” работы. Для такого случая мы просто будем ставить на выполнение параллельные работы одну за другой, пока не получится граф, в котором не останется работ, выполняемых одновременно в количестве, равном числу поваров (в данном случае он 1).

= 4 Дизайн интерфейса

image::PrototypeA5.png[]

image::PrototypeA6.png[]

image::PrototypeA7.png[]


= Приложение A

 Пользователю предоставляется возможность создать шаги, используя шаблоны приложения. Опорным является:
 <Действие> <Одно или несколько слов в зависимости от выбранного действия>.
 
 На начальном анализе двух блюд я выделил следующие шаблоны действий:
 
 . Нарезать <Продукт> <Как нарезать>.
   Пример: Нарезать лук соломкой.
 . Смешать <Продукт/Номер шага>,…<Продукт/Номер шага>.
   Пример: Смешать барбарис, куркуму, соль, перец.
   Пример: Смешать 2 номер шага, куркуму.
 . Обжарить <Продукт/Номер шага> до <Модификатор, заполняется пользователем вручную>
   Пример: Обжарить лук до золотистого цвета
 . Тушить <Продукт/Номер шага> <Время>.
   Пример: Тушить свинину 5-7 минут
 . Промыть <Продукт/Номер шага> <Модификатор, заполняется пользователем вручную>.
   Пример: Промыть рис 5-6 раз в холодной воде.
 . Варить <Продукт/Номер шага> <время> <Модификатор, заполняется пользователем вручную>.
   Пример: Варить рис 20 минут, пока рис не впитает воду.
 . Положить <Продукт/Номер шага>, <Модификатор, заполняется пользователем вручную>.
   Пример: Положить чеснок в рис, положить в середину, вдавить его в рис. Деревянной палочкой сделать отверстия (рис и мясо не перемешивать) для выхода пара.

= Приложение Б

 При оптимизации использования ресурса рабочей силы чаще всего сетевые работы стремятся организовать таким образом, чтобы:
 
 * Количество одновременно занятых исполнителей было минимальным;
 * Выровнять потребность в людских ресурсах на протяжении срока выполнения проекта.
 
 Суть оптимизации загрузки сетевых моделей по критерию «минимум исполнителей» заключается в следующем: необходимо таким образом организовать выполнения сетевых работ, чтобы количество одновременно работающих исполнителей было минимальным. Для проведения подобных видов оптимизации необходимо построить и проанализировать график привязки и график загрузки.
 
 График привязки отображает взаимосвязь выполняемых работ во времени и строится на основе данных либо о продолжительности работ, либо о ранних сроках начала и окончания работ. При первом способе построения необходимо помнить, что работа   может начать выполняться только после того как будут выполнены все предшествующие ей работы  . По вертикальной оси графика привязки откладываются коды работ, по горизонтальной оси - длительность работ (раннее начало и раннее окончание работ).
 
 На графике загрузки по горизонтальной оси откладывается время, например в днях, по вертикальной - количество человек, занятых работой в каждый конкретный день. Для построения графика загрузки необходимо:
 
 * на графике привязки над каждой работой написать количество ее исполнителей;
 * подсчитать количество работающих в каждый день исполнителей и отложить на графике загрузки.
 
 Для удобства построения и анализа графики загрузки и привязки следует располагать один над другим.
 
 Описанные виды оптимизации загрузки выполняются за счет сдвига во времени некритических работ, т.е. работ, имеющих полный и/или свободный резервы времени. Полный и свободный резервы любой работы можно определить без специальных расчетов, анализируя только график привязки. Сдвиг работы означает, что она будет выполняться уже в другие дни (т.е. изменится время ее начала и окончания), что в свою очередь приведет к изменению количества исполнителей, работающих одновременно (т.е. уровня ежедневной загрузки сети).
 
==== Пример проведения оптимизации сетевой модели по критерию «Минимум исполнителей»
 
 
 Графики привязки и загрузки для исходных данных из табл.1, представлены на рис.2.
 
 Допустим, что организация, выполняющая проект, имеет в распоряжении только   исполнителей. Но в соответствии с графиком загрузки (рис.2.1), в течении интервала времени с 3 по 11 день для выполнения проекта требуется работа одновременно 19, 17 и затем 18 человек. Таким образом, возникает необходимость снижения максимального количества одновременно занятых исполнителей с 19 до 15 человек.
 
.Исходные данные для оптимизации загрузки
|===
|Код работ|Продолжительность работ|	Количество исполнителей

|(1,2)|4|6
|(1,3)|3|1
|(1,4)|5|5
|(2,5)|7|3
|(2,6)|10|1
|(3,6)|8|8
|(4,6)|12|4
|(4,7)|9|2
|(5,8)|8|6
|(6,8)|10|1
|(7,8)|11|3

|===
 
image::PrototypeA8.png[]
 Рисунок 1. Сетевая модель
 
.Таблица временных параметров работ
|===
|(i,j)|t(i,j)|Tpn(i,j)|Tpo(i,j)|Tпн(i,j)|Tпо(i,j)|Rп(i,j)|Rc(i,j)|

|(1,2)|4|6
|1,2|4	0|4|3	7|3|0
|1,3|3	0|3|6	9|6|0
|1,4|5	0|5|0	5|0|0
|2,5|7	4|11|12	19|8|0
|2,6|10	4|14|7	17|3|3
|3,6|8	3|11|9	17|6|6
|4,6|12	5|17|5	17|0|0
|4,7|9	5|14|7	16|2|0
|5,8|8	11|19|19|27	8|8
|6,8|10	17|27|17|27	0|0
|7,8|11	14|25|16|27	2|2


|===


 Проанализируем возможность уменьшения загрузки (19 человек) в течении 4-го дня. Используя Rс(3,6)=6, сдвинем работу (3,6) на 1 день, что снизит загрузку 4-го дня до 11 человек, но при этом в 12-й день появится пик - 21 исполнитель. Для его устранения достаточно сдвинуть работу (5,8) на 1 дней, используя Rс(5,8)=8.
 
 Проанализируем возможность уменьшения загрузки (18 человек) с 6-го по 11-й день, т.е. в течении интервала времени в 6 дней. Так работа (2,5) является единственной, которую можно сдвинуть таким образом, чтобы она не выполнялась в указанные 6 дней с 6-го по 11-й день. Для этого, используя Rп(2,5)=8, сдвинем работу (2,5) на 8 дней, после чего она будет начинаться уже не в 4-й, а в 12 день, к чему мы и стремились.

image::Prototype9.png[]
 Рисунок 2 - Графики загрузки (а) и привязки (b) до оптимизации

 Но поскольку Rс(2,5)=0 и для сдвига работы (2,5) был использован полный резерв, то это влечет за собой обязательный сдвиг на 7 дней работы (5,8), следующей за работой (2,5).
 
 В результате произведенных сдвигов максимальная загрузка сетевой модели уменьшилась с 19 до 15 человек, что и являлось целью проводимой оптимизации. Окончательные изменения в графиках привязки и загрузки показаны на рис.3 пунктирной линией.

image::Prototype10.png[]
 Рисунок 3 - Графики загрузки (а) и привязки (b) после оптимизации
 
 Проведенная оптимизация продемонстрировала следующее различие использования свободных и полных резервов работ. Так сдвиг работы на время в пределах ее свободного резерва не меняет моменты начала последующих за ней работ. В то же время сдвиг работы на время, которое находится в пределах ее полного резерва, но превышает ее свободный резерв, влечет сдвиг последующих за ней работ.